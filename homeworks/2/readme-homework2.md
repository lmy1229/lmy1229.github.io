<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

#基础实验2: js练习

吕梦扬 <br>
2014013452 <br>
<a href="mailto:lmy1229@126.com">lmy1229@126.com</a>

------------------------------------------

##基础练习
####练习1
- 返回值: `'undefined'`
- 原因: 代码中调用`arguments[0]`时,处于匿名自启动的函数的作用域中,而在这个作用域中并没有定义`num`这个变量.因此返回`'undefined'`.若要使得函数能够正常返回`Number`,需要将代码改为
	
		(function() {
			return typeof arguments[0].call(func);
		})(func.getNum);
		
####练习2
- 返回值: `'undefined'`
- 原因: `new`运算符会产生一个新的对象,并将其设置为上下文作为调用的构造函数的作用域. 但是在构造函数中返回了`foo`,是一个引用类型的实例.在这种情况下脚本引擎会将返回的引用类型作为`new`语句的返回值. 因此`new foo;`语句的返回值就是`foo`函数,而不是一个新的对象.`new new foo;`语句也类似.在`foo`这个函数的作用域中,x并没有定义.因此返回`undefined`.

####练习3
- 返回值: `'function'`
- 原因: 在预编译阶段,由于`function bar(){...}`和`function foo(){...}`都是显示的函数声明,因此会被预编译. 虽然`var foo = '11'`这一行也会被预编译,但是只是为`foo`变量留出空间,并没有初始化.因此`foo`的内容还是函数.在执行`bar()`时,由于之后对于`foo`的赋值语句还没有执行,因此返回的`foo`是函数类型的.

####练习4
- 返回值: `3` 和 `1`
- 原因: 由于函数`go()`在全局作用域中运行,因此返回全局作用域中的`x = 3`, 而函数`foo.baz.bar()`在`foo.baz`作用域中运行,因此返回`foo.baz`中的`x = 1`

####练习5
- 返回值 `'undefined'`
- 原因: 函数`aaa`中`{ test: 1 }`的大括号`{`没有和`return`写在同一行,且`return`是一个合法的语句,因此,js会认为`return`是单独的一个语句,因此函数不返回任何值,于是`typeof aaa()`获得了`undefined`


-----------------------------------------
##进阶练习

###进阶练习1-比赛预测
#####设计思路
- 预测比赛结果的基本思路就是模拟比赛的过程, 即模拟两个队伍进行比赛的过程,然后胜者晋级,败者淘汰. 但是由于题目中要求比赛胜利概率与实力成正比,而不是通过比较实力大小直接决出胜负,因此可能会出现很多情况,不同情况出现的概率不同.为了更加直观且便捷地展示比赛结果,以及各个结果出现的可能性,引入**广义队**的概念. **广义队**的结构如下
	
		var team = {
			team1: prob1,
			team2: prob2,
			...
		}
	其中`team1...`表示队伍的名称,`prob...`表示该队伍出现在这个*广义队*中的可能性.
- 定义了**广义队**之后就可以计算两个队的比赛结果了. 两个**广义队***team1*,*team2*的比赛结果*result*也是一个**广义队**.由全概率公式*team1*中的某一个队伍*team*出现在*result*中的概率是
$$result[team] = team1[team] \cdot \sum_{t \in team2}(team2[t] \cdot \frac{abil(team)}{abil(team) + abil(t)})$$
	在*team2*中的队伍与之类似.
- 定义了两个**广义队**的比赛结果之后,需要能够模拟比赛过程,位于`function predict(abil, sched, country)`.`predict`接受3个参数: 
	1. `abil`: 用户心目中的队伍实力评分. 是一个object
	2. `sched`: 赛程表, 是一个数组. 用于扩展程序.
	3. `country`: 用户想要求胜率的队伍.
	`predict`函数接受的第2个参数`sched`为比赛的赛程表,是一个数组,该函数将`sched`数组两两比赛晋级,然后将比赛的结果继续两两比赛晋级,直到最终只有1个队伍存在(**广义队**).这个队伍就是最终比赛的结果.
- 本程序中引入了赛程表和**广义队**,使得程序扩展比较容易. 没有局限于本题中16支参赛队的限制,而是可以任意2的幂支队伍进行比赛,只需修改赛程表数组即可	

####测试结果
- 为了方便,一共设计了两个测试
	1. 所有队伍的能力值相同. 此时,所有队伍胜利的概率应该都相同,为`0.0625`. 实际测试结果确实为`0.0625`
	2. 有一个队伍的能力是其他队伍的9倍,由概率论知识,这个队伍的胜率是`0.9^4 = 0.6561`. 实际测试结果确实为`0.6561`

###进阶练习2-查找信息
#####思路
此题比较简单,直接通过`javascript`函数中的`arguments`和`typeof`来判断参数类型,根据不同的类型进行不同的处理.


---------------------------------------
##Bonus
###Bonus1-找不同
采用了两种方法:

1. 暴力搜索法, 遍历所有第二个集合中的元素,在第一个集合中查找是否有相同的, 如果没有,则加入结果的集合中. 算法复杂度**O(n*m)**.其中n为第一个集合的元素个数,m为第二个集合的元素个数.
2. 首先使用JavaScript的`sort()`函数将两个集合分别排序,然后使用类似于**归并**的思想查找在集合2而不在集合1中的元素. 算法复杂度为**O(n*log(n)+m*log(m))**

###Bonus2-排序算法
将算法导论中的基本排序算法(冒泡,插入,选择排序)用JavaScript实现一遍, 分别为`bubble_sort`, `insertion_sort`和`selection_sort`. 这些函数均支持在第二个参数处传入一个比较函数来自定义排序的表现.

--------------------------------------
##注意
1. 本markdown文档为了输入公式,使用了`MathJax.js`.由于这个库本身比较大,因此采用了网络加载的形式.请在联网的情况下打开本文档,否则可能出现公式无法正常显示的问题.
2. 所有代码的测试样例请参见`js`文件尾部的`// for testing`部分.
